<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜å¹¶å‘ç¨³å®šæ€§æµ‹è¯•</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .test-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .config-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .config-section h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .config-item {
            display: flex;
            flex-direction: column;
        }

        .config-item label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .config-item input {
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .config-item input:focus {
            outline: none;
            border-color: #667eea;
        }

        .status-section {
            margin-bottom: 30px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .status-card {
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .status-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.1);
        }

        .status-card h4 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .status-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .status-label {
            color: #666;
            font-size: 0.9em;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e5e9;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-section {
            margin-top: 30px;
        }

        .results-tabs {
            display: flex;
            border-bottom: 2px solid #e1e5e9;
            margin-bottom: 20px;
        }

        .results-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }

        .results-tab.active {
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .results-content {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            min-height: 300px;
        }

        .log-container {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .chart-container {
            width: 100%;
            height: 300px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .alert-danger {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .recommendations {
            background: white;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin-top: 20px;
        }

        .recommendations h4 {
            color: #333;
            margin-bottom: 15px;
        }

        .recommendations ul {
            list-style: none;
            padding: 0;
        }

        .recommendations li {
            padding: 8px 0;
            border-bottom: 1px solid #e1e5e9;
            color: #555;
        }

        .recommendations li:last-child {
            border-bottom: none;
        }

        .recommendations li::before {
            content: "ğŸ’¡";
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ é«˜å¹¶å‘ç¨³å®šæ€§æµ‹è¯•</h1>
            <p>éªŒè¯ç®¡ç†é¡µé¢åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹çš„ç¨³å®šæ€§å’Œæ€§èƒ½è¡¨ç°</p>
        </div>

        <div class="content">
            <!-- æµ‹è¯•æ§åˆ¶åŒºåŸŸ -->
            <div class="test-controls">
                <button id="startTest" class="btn btn-primary">
                    <span id="startTestText">å¼€å§‹æµ‹è¯•</span>
                </button>
                <button id="stopTest" class="btn btn-danger" disabled>åœæ­¢æµ‹è¯•</button>
                <button id="generateReport" class="btn btn-primary" disabled>ç”ŸæˆæŠ¥å‘Š</button>
            </div>

            <!-- æµ‹è¯•é…ç½® -->
            <div class="config-section">
                <h3>ğŸ“‹ æµ‹è¯•é…ç½®</h3>
                <div class="config-grid">
                    <div class="config-item">
                        <label for="duration">æµ‹è¯•æŒç»­æ—¶é—´ (ç§’)</label>
                        <input type="number" id="duration" value="60" min="10" max="300">
                    </div>
                    <div class="config-item">
                        <label for="concurrentUsers">å¹¶å‘ç”¨æˆ·æ•°</label>
                        <input type="number" id="concurrentUsers" value="10" min="1" max="50">
                    </div>
                    <div class="config-item">
                        <label for="tabSwitchInterval">æ ‡ç­¾é¡µåˆ‡æ¢é—´éš” (ms)</label>
                        <input type="number" id="tabSwitchInterval" value="2000" min="500" max="10000">
                    </div>
                    <div class="config-item">
                        <label for="apiCallInterval">APIè°ƒç”¨é—´éš” (ms)</label>
                        <input type="number" id="apiCallInterval" value="1000" min="200" max="5000">
                    </div>
                </div>
            </div>

            <!-- æµ‹è¯•è¿›åº¦ -->
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>

            <!-- å®æ—¶çŠ¶æ€ -->
            <div class="status-section">
                <h3>ğŸ“Š å®æ—¶çŠ¶æ€</h3>
                <div class="status-grid">
                    <div class="status-card">
                        <h4>æµ‹è¯•è¿›åº¦</h4>
                        <div id="testProgress" class="status-value">0%</div>
                        <div class="status-label">å®Œæˆåº¦</div>
                    </div>
                    <div class="status-card">
                        <h4>æ ‡ç­¾é¡µåˆ‡æ¢</h4>
                        <div id="tabSwitchCount" class="status-value">0</div>
                        <div class="status-label">æ¬¡æ•°</div>
                    </div>
                    <div class="status-card">
                        <h4>APIè°ƒç”¨</h4>
                        <div id="apiCallCount" class="status-value">0</div>
                        <div class="status-label">æ¬¡æ•°</div>
                    </div>
                    <div class="status-card">
                        <h4>é”™è¯¯æ•°é‡</h4>
                        <div id="errorCount" class="status-value">0</div>
                        <div class="status-label">ä¸ª</div>
                    </div>
                    <div class="status-card">
                        <h4>å†…å­˜ä½¿ç”¨</h4>
                        <div id="memoryUsage" class="status-value">0MB</div>
                        <div class="status-label">å½“å‰</div>
                    </div>
                    <div class="status-card">
                        <h4>å¹³å‡å“åº”æ—¶é—´</h4>
                        <div id="avgResponseTime" class="status-value">0ms</div>
                        <div class="status-label">æ¯«ç§’</div>
                    </div>
                </div>
            </div>

            <!-- æµ‹è¯•ç»“æœ -->
            <div class="results-section">
                <h3>ğŸ“ˆ æµ‹è¯•ç»“æœ</h3>
                <div class="results-tabs">
                    <button class="results-tab active" data-tab="summary">æ¦‚è§ˆ</button>
                    <button class="results-tab" data-tab="performance">æ€§èƒ½</button>
                    <button class="results-tab" data-tab="errors">é”™è¯¯</button>
                    <button class="results-tab" data-tab="logs">æ—¥å¿—</button>
                </div>
                <div class="results-content">
                    <div id="summaryTab" class="tab-content">
                        <div id="summaryContent">
                            <p>ç‚¹å‡»"å¼€å§‹æµ‹è¯•"å¼€å§‹é«˜å¹¶å‘ç¨³å®šæ€§æµ‹è¯•...</p>
                        </div>
                    </div>
                    <div id="performanceTab" class="tab-content" style="display: none;">
                        <div class="chart-container">
                            <canvas id="performanceChart"></canvas>
                        </div>
                    </div>
                    <div id="errorsTab" class="tab-content" style="display: none;">
                        <div id="errorsContent">
                            <p>æš‚æ— é”™è¯¯ä¿¡æ¯</p>
                        </div>
                    </div>
                    <div id="logsTab" class="tab-content" style="display: none;">
                        <div id="logsContainer" class="log-container">
                            æµ‹è¯•æ—¥å¿—å°†åœ¨è¿™é‡Œæ˜¾ç¤º...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class StabilityTestRunner {
            constructor() {
                this.isRunning = false;
                this.testResults = {
                    tabSwitching: [],
                    apiCalls: [],
                    memoryUsage: [],
                    errors: [],
                    performance: [],
                    startTime: null,
                    endTime: null
                };
                this.config = {
                    duration: 60000,
                    concurrentUsers: 10,
                    tabSwitchInterval: 2000,
                    apiCallInterval: 1000
                };
                this.updateInterval = null;
                this.logContainer = document.getElementById('logsContainer');
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('startTest').addEventListener('click', () => this.startTest());
                document.getElementById('stopTest').addEventListener('click', () => this.stopTest());
                document.getElementById('generateReport').addEventListener('click', () => this.generateReport());

                // æ ‡ç­¾é¡µåˆ‡æ¢
                document.querySelectorAll('.results-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchTab(e.target.dataset.tab);
                    });
                });

                // é…ç½®æ›´æ–°
                ['duration', 'concurrentUsers', 'tabSwitchInterval', 'apiCallInterval'].forEach(id => {
                    document.getElementById(id).addEventListener('change', (e) => {
                        this.updateConfig(id, parseInt(e.target.value));
                    });
                });
            }

            updateConfig(key, value) {
                if (key === 'duration') {
                    this.config.duration = value * 1000;
                } else {
                    this.config[key] = value;
                }
                this.log(`é…ç½®æ›´æ–°: ${key} = ${value}`);
            }

            async startTest() {
                if (this.isRunning) return;

                this.log('ğŸš€ å¼€å§‹é«˜å¹¶å‘ç¨³å®šæ€§æµ‹è¯•');
                this.isRunning = true;
                this.testResults.startTime = Date.now();
                
                // æ›´æ–°UIçŠ¶æ€
                document.getElementById('startTest').disabled = true;
                document.getElementById('stopTest').disabled = false;
                document.getElementById('generateReport').disabled = true;
                document.getElementById('startTestText').innerHTML = '<span class="loading"></span>æµ‹è¯•ä¸­...';

                // é‡ç½®æµ‹è¯•ç»“æœ
                this.resetTestResults();

                // å¼€å§‹å®æ—¶æ›´æ–°
                this.startRealTimeUpdates();

                try {
                    // å¹¶è¡Œæ‰§è¡Œæµ‹è¯•ä»»åŠ¡
                    await Promise.all([
                        this.runConcurrentTabSwitching(),
                        this.runConcurrentApiCalls(),
                        this.monitorMemoryUsage(),
                        this.monitorPerformance()
                    ]);
                } catch (error) {
                    this.log(`âŒ æµ‹è¯•æ‰§è¡Œå¤±è´¥: ${error.message}`);
                    this.testResults.errors.push({
                        type: 'test_execution',
                        message: error.message,
                        timestamp: Date.now()
                    });
                } finally {
                    this.stopTest();
                }
            }

            stopTest() {
                if (!this.isRunning) return;

                this.log('ğŸ›‘ æµ‹è¯•å·²åœæ­¢');
                this.isRunning = false;
                this.testResults.endTime = Date.now();

                // åœæ­¢å®æ—¶æ›´æ–°
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }

                // æ›´æ–°UIçŠ¶æ€
                document.getElementById('startTest').disabled = false;
                document.getElementById('stopTest').disabled = true;
                document.getElementById('generateReport').disabled = false;
                document.getElementById('startTestText').textContent = 'å¼€å§‹æµ‹è¯•';

                // æ›´æ–°è¿›åº¦ä¸º100%
                this.updateProgress(100);

                this.log('âœ… æµ‹è¯•å®Œæˆï¼Œå¯ä»¥ç”ŸæˆæŠ¥å‘Š');
            }

            async runConcurrentTabSwitching() {
                const tabs = ['overview', 'bookings', 'services', 'users', 'system'];
                const promises = [];
                
                for (let i = 0; i < this.config.concurrentUsers; i++) {
                    promises.push(this.simulateUserTabSwitching(i, tabs));
                }
                
                await Promise.all(promises);
            }

            async simulateUserTabSwitching(userId, tabs) {
                const startTime = Date.now();
                let switchCount = 0;
                
                while (this.isRunning && (Date.now() - startTime) < this.config.duration) {
                    try {
                        const randomTab = tabs[Math.floor(Math.random() * tabs.length)];
                        const switchStartTime = performance.now();
                        
                        // æ¨¡æ‹Ÿæ ‡ç­¾é¡µåˆ‡æ¢
                        await this.simulateTabSwitch(randomTab);
                        
                        const switchDuration = performance.now() - switchStartTime;
                        switchCount++;
                        
                        this.testResults.tabSwitching.push({
                            userId,
                            tab: randomTab,
                            duration: switchDuration,
                            timestamp: Date.now(),
                            success: true
                        });
                        
                        // ç­‰å¾…é—´éš”
                        await this.sleep(this.config.tabSwitchInterval + Math.random() * 1000);
                        
                    } catch (error) {
                        this.testResults.errors.push({
                            type: 'tab_switching',
                            userId,
                            message: error.message,
                            timestamp: Date.now()
                        });
                    }
                }
                
                this.log(`ç”¨æˆ·${userId}å®Œæˆ${switchCount}æ¬¡æ ‡ç­¾é¡µåˆ‡æ¢`);
            }

            async simulateTabSwitch(tab) {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        // æ¨¡æ‹Ÿä¸€äº›è®¡ç®—å¯†é›†å‹æ“ä½œ
                        let sum = 0;
                        for (let i = 0; i < 100000; i++) {
                            sum += Math.random();
                        }
                        resolve(sum);
                    }, Math.random() * 100 + 50);
                });
            }

            async runConcurrentApiCalls() {
                const apiEndpoints = [
                    '/api/statistics/overview',
                    '/api/orders/paginated',
                    '/api/services/lazy',
                    '/api/users',
                    '/api/system/status'
                ];
                
                const promises = [];
                
                for (let i = 0; i < this.config.concurrentUsers; i++) {
                    promises.push(this.simulateUserApiCalls(i, apiEndpoints));
                }
                
                await Promise.all(promises);
            }

            async simulateUserApiCalls(userId, endpoints) {
                const startTime = Date.now();
                let callCount = 0;
                
                while (this.isRunning && (Date.now() - startTime) < this.config.duration) {
                    try {
                        const randomEndpoint = endpoints[Math.floor(Math.random() * endpoints.length)];
                        const callStartTime = performance.now();
                        
                        // æ¨¡æ‹ŸAPIè°ƒç”¨
                        await this.simulateApiCall(randomEndpoint);
                        
                        const callDuration = performance.now() - callStartTime;
                        callCount++;
                        
                        this.testResults.apiCalls.push({
                            userId,
                            endpoint: randomEndpoint,
                            duration: callDuration,
                            timestamp: Date.now(),
                            success: true
                        });
                        
                        // ç­‰å¾…é—´éš”
                        await this.sleep(this.config.apiCallInterval + Math.random() * 500);
                        
                    } catch (error) {
                        this.testResults.errors.push({
                            type: 'api_call',
                            userId,
                            message: error.message,
                            timestamp: Date.now()
                        });
                    }
                }
                
                this.log(`ç”¨æˆ·${userId}å®Œæˆ${callCount}æ¬¡APIè°ƒç”¨`);
            }

            async simulateApiCall(endpoint) {
                return new Promise((resolve, reject) => {
                    const delay = Math.random() * 200 + 100;
                    const failureRate = 0.05;
                    
                    setTimeout(() => {
                        if (Math.random() < failureRate) {
                            reject(new Error(`APIè°ƒç”¨å¤±è´¥: ${endpoint}`));
                        } else {
                            resolve({ data: { success: true, endpoint } });
                        }
                    }, delay);
                });
            }

            async monitorMemoryUsage() {
                const startTime = Date.now();
                
                while (this.isRunning && (Date.now() - startTime) < this.config.duration) {
                    try {
                        const memoryInfo = this.getMemoryInfo();
                        
                        this.testResults.memoryUsage.push({
                            ...memoryInfo,
                            timestamp: Date.now()
                        });
                        
                        await this.sleep(5000);
                        
                    } catch (error) {
                        this.testResults.errors.push({
                            type: 'memory_monitoring',
                            message: error.message,
                            timestamp: Date.now()
                        });
                    }
                }
            }

            getMemoryInfo() {
                if (performance.memory) {
                    return {
                        usedJSHeapSize: performance.memory.usedJSHeapSize,
                        totalJSHeapSize: performance.memory.totalJSHeapSize,
                        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
                    };
                } else {
                    return {
                        usedJSHeapSize: 0,
                        totalJSHeapSize: 0,
                        jsHeapSizeLimit: 0
                    };
                }
            }

            async monitorPerformance() {
                const startTime = Date.now();
                
                while (this.isRunning && (Date.now() - startTime) < this.config.duration) {
                    try {
                        const performanceInfo = this.getPerformanceInfo();
                        
                        this.testResults.performance.push({
                            ...performanceInfo,
                            timestamp: Date.now()
                        });
                        
                        await this.sleep(2000);
                        
                    } catch (error) {
                        this.testResults.errors.push({
                            type: 'performance_monitoring',
                            message: error.message,
                            timestamp: Date.now()
                        });
                    }
                }
            }

            getPerformanceInfo() {
                const navigation = performance.getEntriesByType('navigation')[0];
                
                return {
                    domContentLoaded: navigation ? navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart : 0,
                    loadComplete: navigation ? navigation.loadEventEnd - navigation.loadEventStart : 0,
                    firstPaint: this.getFirstPaint(),
                    firstContentfulPaint: this.getFirstContentfulPaint()
                };
            }

            getFirstPaint() {
                const paintEntries = performance.getEntriesByType('paint');
                const firstPaint = paintEntries.find(entry => entry.name === 'first-paint');
                return firstPaint ? firstPaint.startTime : 0;
            }

            getFirstContentfulPaint() {
                const paintEntries = performance.getEntriesByType('paint');
                const firstContentfulPaint = paintEntries.find(entry => entry.name === 'first-contentful-paint');
                return firstContentfulPaint ? firstContentfulPaint.startTime : 0;
            }

            startRealTimeUpdates() {
                this.updateInterval = setInterval(() => {
                    this.updateRealTimeStatus();
                }, 1000);
            }

            updateRealTimeStatus() {
                if (!this.isRunning) return;

                const elapsed = Date.now() - this.testResults.startTime;
                const progress = Math.min((elapsed / this.config.duration) * 100, 100);
                
                this.updateProgress(progress);
                
                // æ›´æ–°çŠ¶æ€å¡ç‰‡
                document.getElementById('testProgress').textContent = `${progress.toFixed(1)}%`;
                document.getElementById('tabSwitchCount').textContent = this.testResults.tabSwitching.length;
                document.getElementById('apiCallCount').textContent = this.testResults.apiCalls.length;
                document.getElementById('errorCount').textContent = this.testResults.errors.length;
                
                // æ›´æ–°å†…å­˜ä½¿ç”¨
                const latestMemory = this.testResults.memoryUsage[this.testResults.memoryUsage.length - 1];
                if (latestMemory) {
                    const memoryMB = (latestMemory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                    document.getElementById('memoryUsage').textContent = `${memoryMB}MB`;
                }
                
                // æ›´æ–°å¹³å‡å“åº”æ—¶é—´
                const allOperations = [...this.testResults.tabSwitching, ...this.testResults.apiCalls];
                if (allOperations.length > 0) {
                    const avgTime = allOperations.reduce((sum, op) => sum + op.duration, 0) / allOperations.length;
                    document.getElementById('avgResponseTime').textContent = `${avgTime.toFixed(1)}ms`;
                }
            }

            updateProgress(percentage) {
                document.getElementById('progressFill').style.width = `${percentage}%`;
            }

            generateReport() {
                if (!this.testResults.endTime) {
                    alert('è¯·å…ˆå®Œæˆæµ‹è¯•å†ç”ŸæˆæŠ¥å‘Š');
                    return;
                }

                const report = this.calculateReport();
                this.displayReport(report);
                this.log('ğŸ“Š æµ‹è¯•æŠ¥å‘Šå·²ç”Ÿæˆ');
            }

            calculateReport() {
                const duration = this.testResults.endTime - this.testResults.startTime;
                
                return {
                    summary: {
                        duration: duration,
                        totalTabSwitches: this.testResults.tabSwitching.length,
                        totalApiCalls: this.testResults.apiCalls.length,
                        totalErrors: this.testResults.errors.length,
                        successRate: this.calculateSuccessRate()
                    },
                    performance: {
                        averageTabSwitchTime: this.calculateAverageTabSwitchTime(),
                        averageApiCallTime: this.calculateAverageApiCallTime(),
                        memoryUsage: this.analyzeMemoryUsage(),
                        errorRate: this.calculateErrorRate()
                    },
                    stability: {
                        memoryLeaks: this.detectMemoryLeaks(),
                        performanceDegradation: this.detectPerformanceDegradation(),
                        errorPatterns: this.analyzeErrorPatterns()
                    },
                    recommendations: this.generateRecommendations()
                };
            }

            calculateSuccessRate() {
                const totalOperations = this.testResults.tabSwitching.length + this.testResults.apiCalls.length;
                const successfulOperations = this.testResults.tabSwitching.filter(t => t.success).length + 
                                            this.testResults.apiCalls.filter(a => a.success).length;
                
                return totalOperations > 0 ? (successfulOperations / totalOperations * 100).toFixed(2) : 0;
            }

            calculateAverageTabSwitchTime() {
                if (this.testResults.tabSwitching.length === 0) return 0;
                
                const totalTime = this.testResults.tabSwitching.reduce((sum, t) => sum + t.duration, 0);
                return (totalTime / this.testResults.tabSwitching.length).toFixed(2);
            }

            calculateAverageApiCallTime() {
                if (this.testResults.apiCalls.length === 0) return 0;
                
                const totalTime = this.testResults.apiCalls.reduce((sum, a) => sum + a.duration, 0);
                return (totalTime / this.testResults.apiCalls.length).toFixed(2);
            }

            analyzeMemoryUsage() {
                if (this.testResults.memoryUsage.length === 0) return {};
                
                const memoryData = this.testResults.memoryUsage;
                const maxMemory = Math.max(...memoryData.map(m => m.usedJSHeapSize));
                const minMemory = Math.min(...memoryData.map(m => m.usedJSHeapSize));
                const avgMemory = memoryData.reduce((sum, m) => sum + m.usedJSHeapSize, 0) / memoryData.length;
                
                return {
                    max: (maxMemory / 1024 / 1024).toFixed(2) + 'MB',
                    min: (minMemory / 1024 / 1024).toFixed(2) + 'MB',
                    average: (avgMemory / 1024 / 1024).toFixed(2) + 'MB',
                    growth: ((maxMemory - minMemory) / 1024 / 1024).toFixed(2) + 'MB'
                };
            }

            calculateErrorRate() {
                const totalOperations = this.testResults.tabSwitching.length + this.testResults.apiCalls.length;
                return totalOperations > 0 ? (this.testResults.errors.length / totalOperations * 100).toFixed(2) : 0;
            }

            detectMemoryLeaks() {
                if (this.testResults.memoryUsage.length < 2) return false;
                
                const firstMemory = this.testResults.memoryUsage[0].usedJSHeapSize;
                const lastMemory = this.testResults.memoryUsage[this.testResults.memoryUsage.length - 1].usedJSHeapSize;
                const growth = lastMemory - firstMemory;
                
                return growth > 50 * 1024 * 1024;
            }

            detectPerformanceDegradation() {
                if (this.testResults.tabSwitching.length < 10) return false;
                
                const firstHalf = this.testResults.tabSwitching.slice(0, Math.floor(this.testResults.tabSwitching.length / 2));
                const secondHalf = this.testResults.tabSwitching.slice(Math.floor(this.testResults.tabSwitching.length / 2));
                
                const firstHalfAvg = firstHalf.reduce((sum, t) => sum + t.duration, 0) / firstHalf.length;
                const secondHalfAvg = secondHalf.reduce((sum, t) => sum + t.duration, 0) / secondHalf.length;
                
                return secondHalfAvg > firstHalfAvg * 1.5;
            }

            analyzeErrorPatterns() {
                const errorTypes = {};
                
                this.testResults.errors.forEach(error => {
                    if (!errorTypes[error.type]) {
                        errorTypes[error.type] = 0;
                    }
                    errorTypes[error.type]++;
                });
                
                return errorTypes;
            }

            generateRecommendations() {
                const recommendations = [];
                
                const errorRate = parseFloat(this.calculateErrorRate());
                if (errorRate > 5) {
                    recommendations.push('é”™è¯¯ç‡è¾ƒé«˜ï¼Œå»ºè®®æ£€æŸ¥é”™è¯¯å¤„ç†æœºåˆ¶å’ŒAPIç¨³å®šæ€§');
                }
                
                if (this.detectMemoryLeaks()) {
                    recommendations.push('æ£€æµ‹åˆ°å¯èƒ½çš„å†…å­˜æ³„æ¼ï¼Œå»ºè®®æ£€æŸ¥äº‹ä»¶ç›‘å¬å™¨å’Œå®šæ—¶å™¨çš„æ¸…ç†');
                }
                
                if (this.detectPerformanceDegradation()) {
                    recommendations.push('æ£€æµ‹åˆ°æ€§èƒ½é™çº§ï¼Œå»ºè®®ä¼˜åŒ–é•¿æ—¶é—´è¿è¡Œçš„æ“ä½œ');
                }
                
                const avgTabSwitchTime = parseFloat(this.calculateAverageTabSwitchTime());
                if (avgTabSwitchTime > 500) {
                    recommendations.push('æ ‡ç­¾é¡µåˆ‡æ¢æ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®ä¼˜åŒ–æ•°æ®åŠ è½½å’Œæ¸²æŸ“é€»è¾‘');
                }
                
                const avgApiCallTime = parseFloat(this.calculateAverageApiCallTime());
                if (avgApiCallTime > 1000) {
                    recommendations.push('APIè°ƒç”¨æ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®ä¼˜åŒ–åç«¯å“åº”æ—¶é—´æˆ–å®ç°æ›´å¥½çš„ç¼“å­˜ç­–ç•¥');
                }
                
                if (recommendations.length === 0) {
                    recommendations.push('ç³»ç»Ÿåœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹è¡¨ç°è‰¯å¥½ï¼Œæ— æ˜æ˜¾é—®é¢˜');
                }
                
                return recommendations;
            }

            displayReport(report) {
                const summaryContent = document.getElementById('summaryContent');
                
                let alertClass = 'alert-success';
                const errorRate = parseFloat(report.performance.errorRate);
                if (errorRate > 10) {
                    alertClass = 'alert-danger';
                } else if (errorRate > 5) {
                    alertClass = 'alert-warning';
                }
                
                summaryContent.innerHTML = `
                    <div class="alert ${alertClass}">
                        <strong>æµ‹è¯•å®Œæˆï¼</strong> é”™è¯¯ç‡: ${report.performance.errorRate}%ï¼ŒæˆåŠŸç‡: ${report.summary.successRate}%
                    </div>
                    
                    <div class="status-grid">
                        <div class="status-card">
                            <h4>æµ‹è¯•æ—¶é•¿</h4>
                            <div class="status-value">${(report.summary.duration / 1000).toFixed(1)}s</div>
                        </div>
                        <div class="status-card">
                            <h4>æ ‡ç­¾é¡µåˆ‡æ¢</h4>
                            <div class="status-value">${report.summary.totalTabSwitches}</div>
                        </div>
                        <div class="status-card">
                            <h4>APIè°ƒç”¨</h4>
                            <div class="status-value">${report.summary.totalApiCalls}</div>
                        </div>
                        <div class="status-card">
                            <h4>é”™è¯¯æ•°é‡</h4>
                            <div class="status-value">${report.summary.totalErrors}</div>
                        </div>
                        <div class="status-card">
                            <h4>å¹³å‡æ ‡ç­¾é¡µåˆ‡æ¢æ—¶é—´</h4>
                            <div class="status-value">${report.performance.averageTabSwitchTime}ms</div>
                        </div>
                        <div class="status-card">
                            <h4>å¹³å‡APIè°ƒç”¨æ—¶é—´</h4>
                            <div class="status-value">${report.performance.averageApiCallTime}ms</div>
                        </div>
                    </div>
                    
                    <div class="recommendations">
                        <h4>ğŸ’¡ ä¼˜åŒ–å»ºè®®</h4>
                        <ul>
                            ${report.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                        </ul>
                    </div>
                `;
                
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                const errorsContent = document.getElementById('errorsContent');
                if (report.summary.totalErrors > 0) {
                    errorsContent.innerHTML = `
                        <h4>é”™è¯¯ç»Ÿè®¡</h4>
                        <pre>${JSON.stringify(report.stability.errorPatterns, null, 2)}</pre>
                        <h4>å†…å­˜åˆ†æ</h4>
                        <pre>${JSON.stringify(report.performance.memoryUsage, null, 2)}</pre>
                        <h4>ç¨³å®šæ€§åˆ†æ</h4>
                        <p>å†…å­˜æ³„æ¼æ£€æµ‹: ${report.stability.memoryLeaks ? 'âš ï¸ æ£€æµ‹åˆ°' : 'âœ… æ­£å¸¸'}</p>
                        <p>æ€§èƒ½é™çº§æ£€æµ‹: ${report.stability.performanceDegradation ? 'âš ï¸ æ£€æµ‹åˆ°' : 'âœ… æ­£å¸¸'}</p>
                    `;
                } else {
                    errorsContent.innerHTML = '<div class="alert alert-success">ğŸ‰ æµ‹è¯•è¿‡ç¨‹ä¸­æœªå‘ç°é”™è¯¯ï¼</div>';
                }
            }

            switchTab(tabName) {
                // æ›´æ–°æ ‡ç­¾é¡µçŠ¶æ€
                document.querySelectorAll('.results-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                
                // æ˜¾ç¤ºå¯¹åº”å†…å®¹
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.style.display = 'none';
                });
                document.getElementById(`${tabName}Tab`).style.display = 'block';
            }

            resetTestResults() {
                this.testResults = {
                    tabSwitching: [],
                    apiCalls: [],
                    memoryUsage: [],
                    errors: [],
                    performance: [],
                    startTime: null,
                    endTime: null
                };
                
                // é‡ç½®UI
                document.getElementById('testProgress').textContent = '0%';
                document.getElementById('tabSwitchCount').textContent = '0';
                document.getElementById('apiCallCount').textContent = '0';
                document.getElementById('errorCount').textContent = '0';
                document.getElementById('memoryUsage').textContent = '0MB';
                document.getElementById('avgResponseTime').textContent = '0ms';
                document.getElementById('progressFill').style.width = '0%';
                
                this.logContainer.textContent = 'æµ‹è¯•æ—¥å¿—å°†åœ¨è¿™é‡Œæ˜¾ç¤º...';
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[${timestamp}] ${message}\n`;
                this.logContainer.textContent += logMessage;
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
                console.log(message);
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // åˆå§‹åŒ–æµ‹è¯•è¿è¡Œå™¨
        const testRunner = new StabilityTestRunner();
    </script>
</body>
</html>